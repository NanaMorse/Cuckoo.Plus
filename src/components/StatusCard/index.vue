<template>
  <div class="status-card-container" @dragenter="onDragFileOver">
    <mu-card class="status-card status-card-bg-color" v-loading="isCardLoading"
             v-drag-over="isFileDragOver"
             @cuckooDragOver="onDragFileOver"
             @cuckooDragleave="isFileDragOver = false"
             @cuckooDrop="onDropFile">

      <card-header :status="status" @deleteStatus="isCardLoading = true"/>

      <div class="spoiler-text-area secondary-read-text-color" v-if="status.spoiler_text">
        <span v-html="status.spoiler_text"/>
        <mu-button flat small class="secondary-theme-text-color" :style="{ minWidth: 'unset' }"
                   @click="shouldShowContentWhileSpoilerExists = !shouldShowContentWhileSpoilerExists">
          {{ $t(shouldShowContentWhileSpoilerExists ? $i18nTags.statusCard.hide_content : $i18nTags.statusCard.show_content) }}
        </mu-button>
      </div>

      <mu-card-text v-if="status.content" v-show="(status.spoiler_text ? shouldShowContentWhileSpoilerExists : true)"
                    class="status-content main-status-content"
                    v-html="status.content" />

      <mu-divider v-if="!status.media_attachments.length && !(status.pixiv_cards || []).length"/>

      <div class="main-attachment-area">
        <media-panel :mediaList="status.media_attachments" :pixivCards="status.pixiv_cards" :sensitive="status.sensitive"/>
      </div>

      <div v-if="rebloggedStatus" class="reblog-area">
        <div class="reblog-plain-info-area">
          <a @click="onCheckSharedOriginalPost" class="reblog-source-link" v-html="$t($i18nTags.statusCard.originally_shared_by, {
              displayName: rebloggedStatus.account.display_name,
              atName: getAccountAtName(rebloggedStatus.account)
            })">
          </a>
          <mu-card-text v-if="rebloggedStatus.content" class="status-content reblog-status-content" v-html="rebloggedStatus.content" />
        </div>
        <div class="reblog-attachment-area">
          <media-panel :mediaList="rebloggedStatus.media_attachments" :pixivCards="rebloggedStatus.pixiv_cards" :sensitive="rebloggedStatus.sensitive"/>
        </div>
      </div>

      <div class="reply-area-full">
        <div class="full-reply-list" ref="replyListContainer">
          <full-reply-list-item v-for="replierStatus in finalRenderDescendantStatusList"
                                :key="replierStatus.id" :status="replierStatus" @reply="onReplyToStatus(replierStatus)"/>
        </div>
      </div>

      <div class="current-reply-to-info-area" v-if="currentReplyToStatus">
        <mu-chip class="reply-to-account-info" color="primary" @delete="hideFullReplyActionArea" delete>
          <mu-avatar :size="32">
            <img :src="currentReplyToStatus.account.avatar">
          </mu-avatar>
          <span v-html="currentReplyToStatus.account.display_name"/> @{{currentReplyToStatus.account.username}}
        </mu-chip>
      </div>

      <mu-card-actions class="card-action-area">
        <simple-action-bar v-show="!shouldShowFullReplyActionArea" :status="operateTargetStatus"
                           @reply="onReplyToStatus(operateTargetStatus)"/>

        <full-action-bar v-if="isOAuthUser && shouldShowFullReplyActionArea"
                         :currentReplyToStatus="currentReplyToStatus"
                         :descendantStatusList="descendantStatusList"
                         :droppedFiles="droppedFiles" :replySpoilerText.sync="replySpoilerText"
                         :status="operateTargetStatus" :value.sync="replyInputValue" @hide="hideFullReplyActionArea"
                         @loadingStart="isCardLoading = true" @loadingEnd="isCardLoading = false" @replySuccess="onReplySuccess"/>
      </mu-card-actions>
    </mu-card>
  </div>
</template>

<script lang="ts">
  import { Vue, Component, Prop, Watch } from 'vue-property-decorator'
  import { State, Getter, Action } from 'vuex-class'
  import { mastodonentities } from '@/interface'
  import { VisibilityTypes } from '@/constant'

  import CardHeader from './CardHeader'
  import MediaPanel from './MediaPanel'
  import FullReplyListItem from './FullReplyListItem'
  import SimpleActionBar from './SimpleActionBar'
  import FullActionBar from './FullActionBar'

  import VisibilitySelectPopOver from '@/components/VisibilitySelectPopOver'

  import { isContentStatusForExperimentalReBlog } from '@/util'


  @Component({
    components: {
      'card-header': CardHeader,
      'media-panel': MediaPanel,
      'full-reply-list-item': FullReplyListItem,
      'simple-action-bar': SimpleActionBar,
      'full-action-bar': FullActionBar,
      'visibility-select-pop-over': VisibilitySelectPopOver
    }
  })
  class StatusCard extends Vue {

    $router

    $routersInfo

    $confirm

    $refs: {
      replyListContainer: HTMLDivElement
    }

    @State('contextMap') contextMap
    @State('statusMap') statusMap
    @State('currentUserAccount') currentUserAccount: mastodonentities.AuthenticatedAccount
    @State('appStatus') appStatus

    @Getter('getAccountAtName') getAccountAtName
    @Getter('isOAuthUser') isOAuthUser

    @Action('fetchStatusById') fetchStatusById

    currentReplyToStatus: mastodonentities.Status = null

    shouldShowContentWhileSpoilerExists: boolean = false

    shouldShowFullReplyActionArea: boolean = false

    replyInputValue: string = ''

    replySpoilerText: string = ''

    isCardLoading = false

    isFileDragOver = false

    droppedFiles: Array<File> = null

    @Prop() status: mastodonentities.Status

    mounted () {
      this.initExperimentalReblogTargetStatus()
    }

    get shouldHideStatusCard () {
      if (!this.isContentStatusForExperimentalReBlog) return false

      if (!this.statusMap[this.status.in_reply_to_id]) return true

      if (this.descendantStatusList.findIndex(status => status.id === this.status.id) !== 1) return true
    }

    get isContentStatusForExperimentalReBlog () {
      return isContentStatusForExperimentalReBlog(this.currentUserAccount, this.status)
    }

    get rebloggedStatus () {
      return this.operateTargetStatus.reblog
    }

    get operateTargetStatus () {
      if (this.isContentStatusForExperimentalReBlog) {
        return this.statusMap[this.status.in_reply_to_id]
      } else {
        return this.status
      }
    }

    get descendantStatusList (): Array<mastodonentities.Status> {
      if (!this.contextMap[this.operateTargetStatus.id] || !this.contextMap[this.operateTargetStatus.id].descendants) return []

      return this.contextMap[this.operateTargetStatus.id].descendants.map(descendantStatusId => {
        return this.statusMap[descendantStatusId]
      }).filter(s => s).sort((a, b) => {
        return new Date(a.created_at) >= new Date(b.created_at) ? 1 : -1
      })
    }

    get finalRenderDescendantStatusList () {
      if (this.isContentStatusForExperimentalReBlog) {
        return [...this.descendantStatusList].slice(1)
      }

      return this.descendantStatusList
    }

    @Watch('shouldShowFullReplyActionArea')
    onFullReplyActionAreaDisplayToggled (val) {
      if (val) this.$emit('statusCardFocus')
    }

    async initExperimentalReblogTargetStatus () {
      // 好像可以算是冗余设计？
      if (this.isContentStatusForExperimentalReBlog) {
        try {
          this.isCardLoading = true
          await this.fetchStatusById(this.status.in_reply_to_id)
          this.isCardLoading = false

        } catch (e) {
          this.isCardLoading = false
        }
      }
    }

    hideFullReplyActionArea () {
      this.shouldShowFullReplyActionArea = false
      this.currentReplyToStatus = null
      this.replyInputValue = ''
      this.replySpoilerText = ''
    }

    onCheckSharedOriginalPost () {
      this.$router.push({
        name: this.$routersInfo.statuses.name,
        params: {
          statusId: this.status.reblog.id
        }
      })
    }

    onReplyToStatus (status: mastodonentities.Status) {
      this.currentReplyToStatus = status

      let preSetMentions

      if (this.appStatus.settings.onlyMentionTargetUserMode) {
        preSetMentions = [{ acct: status.account.acct }]
      } else {
        preSetMentions = status.mentions.filter(mention => {
          return (mention.id !== this.currentUserAccount.id) && (mention.id !== status.account.id)
        })

        if (status.account.id !== this.currentUserAccount.id || preSetMentions.length === 0) {
          preSetMentions.unshift({
            acct: status.account.acct,
            id: status.account.id
          } as mastodonentities.Mention)
        }
      }

      this.replyInputValue = preSetMentions.reduce((pre, cur) => pre + `@${cur.acct} `, '')

      this.shouldShowFullReplyActionArea = true
    }

    onReplySuccess () {
      this.$nextTick(() => {
        this.$refs.replyListContainer.scrollTo({ top: this.$refs.replyListContainer.scrollHeight, left: 0, behavior: 'smooth' })
      })
    }

    onDragFileOver (e: DragEvent) {
      e.preventDefault()

      this.isFileDragOver = true
    }

    onDropFile (e: DragEvent) {
      e.preventDefault()

      this.isFileDragOver = false

      if (!this.shouldShowFullReplyActionArea) {
        this.onReplyToStatus(this.operateTargetStatus)
      }

      this.droppedFiles = Array.from(e.dataTransfer.files)
    }
  }

  export default StatusCard
</script>

<style lang="less" scoped>
  .status-card-container {
    width: 100%;

    .status-card {
      height: 100%;
      display: flex;
      flex-direction: column;
      transition: box-shadow 0.3s ease-in-out;
    }
  }

  .at-name {
    font-weight: 400;
    font-size: 13px;
  }

  .spoiler-text-area {
    padding: 0 16px 16px;
  }

  .main-status-content {
    padding: 0 16px 16px;
  }

  .main-attachment-area {
    .attachment-list {
      > img {
        width: 100%;
        height: auto;
      }
    }
  }

  .reblog-area {
    .reblog-plain-info-area {
      margin: 16px;

      .reblog-source-link {
        cursor: pointer;
        font-weight: 500;

        .at-name {
          color: unset;
        }
      }

      .reblog-status-content {
        padding: 0;
        margin-top: 8px;
      }
    }
  }

  .reply-area-full {

    .full-reply-list {
      max-height: 400px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .full-reply-status-content {
      padding: 0;
    }
  }

  .current-reply-to-info-area {
    height: 44px;
    line-height: 44px;
    padding-left: 16px;

    .reply-to-account-info {
      margin-top: 6px;
    }
  }

  .card-action-area {
    padding: 0;
  }
</style>

<style lang="less">

  .status-content {
    // https://stackoverflow.com/questions/5241369/word-wrap-a-link-so-it-doesnt-overflow-its-parent-div-width
    word-wrap: break-word;
    > p {
      margin: 0 0 10px 0;
      padding: 0;
    }

    > P:last-child {
      margin-bottom: 0;
    }
  }

  .simple-reply-status-content {
    > p { display: inline }
  }

  .reply-text-input {
    .el-textarea__inner {
      width: 100%;
      outline: none;
      border: none;
      padding: 0;
      resize: none;
    }
  }

  .no-limit-reply-area-height.status-card-container {
    .full-reply-list {
      max-height: unset;
    }
  }
</style>
